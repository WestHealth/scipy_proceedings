:author: Haw-minn Lu
:email: hlu@westhealth.org
:institution: Gary and Mary West Health Institute
:bibliography: ourbib


.. class:: abstract

Most machine learning models, especially artificial neural networks, require numerical, not categorical data. We briefly describe the advantages and disadvantages of common encoding schemes. For example, one-hot encoding is commonly used for attributes with a few unrelated categories and word embeddings for attributes with many related categories (e.g., words). Neither is suitable for encoding attributes with many unrelated categories, such as diagnosis codes in healthcare applications. Application of one-hot encoding for diagnosis codes, for example, can result in extremely high dimensionality with low sample size problems or artificially induce machine learning artifacts, not to mention the explosion of computing resources needed. Quasi-orthonormal encoding (QOE) fills the gap. We briefly show how QOE compares to one-hot encoding. We provide example code of how to implement QOE using popular ML libraries such as Tensorflow and PyTorch and a demonstration of QOE to MNIST handwriting samples.

.. class:: keywords

   terraforming, desert, numerical perspective

============================================================
Quasi-orthonormal Encoding for Machine Learning Applications
============================================================

Introduction
------------

While most popular machine learning methods such as deep learning
require numerical data as input, categorical data is very common
practice. For example, a person's vitals could be a combination of both,
they could include height, weight (numerical) and gender, race
(categorical). The challenge is to convert the categorical data into a
vector of some sort. 

One-hot encoding which is discussed in the next section is very
commonly used these days in machine learning but has the draw back
that it can increase the dimensionality of the data by the cardinality
of the category. For small category, this is not a significant issue
but when categories with high cardinality are present, many problems
can arise as described below.

Quasiorthonormal encoding (QOE) is a generalization of the one-hot
encoding and exploits the fact that in high dimensional vector spaces,
two random vectors are almost always orthogonal. The concept originated
with Kůrková and Kainen :cite:`kurkova`. In many ways, QOE functions
the same as one-hot encoding but does not increase the dimensionality
of the data to the same degree as one-hot encoding. Historically, QOE
was considered for a method of encoding words but modern techinques
such as *word embeddings* are now considered the state of the art
method of encoding language.

Some advantages to QOE include a reduction of dimensionality over that
of using one-hot encoding thus limiting effects of the \`\`curse of
dimensionality'' :cite:`wiki:curse` or the problem of high dimension low sample size
(HDLSS). The advantage over other encodings such as binary, hash, etc.
is that it does not induce artificial geometric relationships that can
cause downstream bias in the results because each label in a category
remains mathematically near orthogonal to the other labels.

We will briefly survey *classuc* encoding methods, discuss the
theoretical aspects of QOE, and present a detailed example implementation
of QOE in tensorflow.

Background
----------

Coding methods can be categorized as *classic*, *contrast*,
*Bayesian* and *word embeddings*. Classic, contrast and Bayseian
encoding are given a good overview treatment by Hale's blog
:cite:`Hale2018` with examples to be found as part of the :code:``scikit-learn`` category
encoding package :cite:`scikit`. He further categorizes the coding techniques as  Notably, *word embeddings* are not mentioned. Both
contrast encoding and Bayesian encoding use the statistics of the data
to facilitate encoding. These two categories may be of use when more
statistical analysis is required, however there has not been widespread
adoption of these emcoding techniques for machine learning. These
encoding techiques can be found as part of the

In a category of its own, word embeddings deserve special mention
:cite:`wiki:wordembeddings`. Word embeddings 
are used to represent words, phrases or even entire documents as a
vector. Their goal is that similar meaning or concepts get mapped to
vectors that are close in the target vector space. Additionally, it is
adapted for encoding a large categorical feature (i.e., words) into a
relatively lower dimensional space.

The remainder of the section will describe some common classic
categorical encodings

Ordinal Encoding
~~~~~~~~~~~~~~~~

To begin our overview of fundamental encoding methods, we start with
Ordinal (Label) Encoding. Ordinal encoding is the simplest and perhaps
most naive approach encoding a categorical feature --- one simply
assigns a number to each member of a category. This is often how data
from surveys are encoded into spreadsheets for easy storage and
calculation of basic statistics. An associated data dictionary is used
to convert the values back and forth between a number and a category.
Take for example the case of gender, male could be encoded as 1 and
female as 2, with a data dictionary as follows:
:code:``{'male': 1, 'female': 2}``

Suppose we have three categories of ethnic groups: White, Black, and
Asian. Under ordinal encoding, suppose What is encoded as 1, Black is
encoded as 2 and Asian is encoded as 3. If a machine learning
classification is somehow confused between Asian and White and decides
to split the difference and report the in-between value (2) which
encodes Black. The issue is that arbitrary gradation between 1 and 3
introduces a natural interpolation (2) that may be nonsense. Thus, the
natural ordering of the numbers imposes an ordered geometrical
relationship between the categories that does not apply.

Nonetheless there are situations where ordinal encoding makes sense. For
example, a 'rate your satisfaction' survey typically encodes five levels
(1) terrible, (2) acceptable (3) mediocre, (4) good, (5) excellent.

One Hot Encoding
~~~~~~~~~~~~~~~~

This is the most common encoding used in machine learning. One hot
encoding takes a category with cardinality :math:`N` and encodes each
categorical value with an :math:`N`-dimensional vector with a single '1'
and the remainder '0's. Take as an example encoding 5 makes of Japanese
Cars: Toyota, Honda, Subaru, Nissan, Mitsubishi. Table :ref:`onehot`
shows a comparison of coding between ordinal and one-hot encodings.

.. raw:: latex

   \begin{table}
     \begin{longtable*}{lcc}
     \toprule
     \textbf{Make} & \textbf{Ordinal} & \textbf{One-Hot} \\
     \midrule
     Toyota &  1 &  (1,0,0,0,0) \\
     Honda &  2 &  (0,1,0,0,0) \\
     Subaru &  3 &  (0,0,1,0,0) \\
     Nissan &  4 &  (0,0,0,1,0) \\
     Mitsubishi &  5 &  (0,0,0,0,1) \\
     \bottomrule
     \end{longtable*}

     \caption{Examples of Ordinal and One-Hot Encodings \DUrole{label}{onehot}}
   \end{table}


The advantage is that one hot encoding doesn't induce an implicit
ordering or between categories. The primary disadvantage is that the
dimensionality of the problem has increased with corresponding increases
in complexity, computation and "the curse of high dimensionality".
This easily leads to the high dimensionality low sample size (HDLSS)
situation, which is a problem for most machine learning methods.

Binary Encoding, Hash Encoding, BaseN Encoding
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Somewhere in between these two are *binary encoding*, *hash encoding*,
and *baseN* encoding. Binary encoding simply labels each category with a
unique binary code and converts the binary code to a vector. Using the
previous example of the Japanese car makes, table :ref:`binary` shows
an example of binary encoding.

.. raw:: latex

   \begin{table}
     \begin{longtable*}{lccc}
     \toprule
     \textbf{Make} & \textbf{Ordinal} & \textbf{as Binary} & \textbf{Binary Code} \\
     \midrule
     \endfirsthead
     Toyota &  1 &  001 &  (0,0,1) \\
     Honda &  2 &  010 &  (0,1,0) \\
     Subaru &  3 &  011 &  (0,1,1) \\
     Nissan &  4 &  100 &  (1,0,0) \\
     Mitsubishi &  5 &  101 &  (1,0,1) \\
     \bottomrule
     \end{longtable*}
     \caption{Example of Binary Codes \DUrole{label}{binary}}

   \end{table}

Hash encoding assigns each category an ordinal value that is then
converted into a binary hash value that is encoded as an :math:`n`-tuple
in the same fashion as the binary encoding. You can view hash encoding
as binary encoding applied to the hashed ordinal value. Hash encoding
has several advantages. First, it is open ended so new categories can be
added later. Second, the resultant dimensionality can be much lower than
one-hot encoding. The chief disadvantage is that categories can collide
if two categories accidentally map into the same hash value. This is a
*hash collision* and must be fixed separately using a resolution
mechanism. A good treatment of hash coding can be found
here :cite:`hash`

Finally, baseN encoding is a generalization of binary encoding that uses
a number base other than 2 (binary). Below is an example of the Japanese
car makes using base 3,

.. raw:: latex

   \begin{table}
     \begin{longtable*}{lcccc}
     \toprule
     & \textbf{as} & \textbf{Ternary} & \textbf{Balanced} \\
     \textbf{Make} & \textbf{Ordinal} & \textbf{Ternary} & \textbf{Code} & \textbf{Ternary Code} \\
     \midrule
     \endfirsthead
     Toyota & 1 & 01 & (0,1) & (0,1) \\
     Honda & 2 & 02 & (0,2) & (0,-1) \\
     Subaru & 3 & 10 & (1,0) & (1,0) \\
     Nissan & 4 & 11 & (1,1) & (1,1) \\
     Mitsubishi & 5 & 12 & (1,2) & (1,-1) \\
     \bottomrule
     \end{longtable*}
     \caption{Example of Ternary Codes}
   \end{table}

A disadvantage of all three of these techniques is that while it does
reduce the dimension of the encoded feature, artificial geometric
relationships may creep in between unrelated categories. For example,
:code:``(0.7,0.7)`` may be confused between Toyota and Honda or a weak Subaru
result, although the effect is not as pronounced as ordinal encoding.

Decoding
~~~~~~~~

Of course, with categorical encoding, the ability to decode an encoded vector back to a category can be very important. If the categorical variable is only an input to a machine learning system, retrieving a category may not be very important. For example, one may have a product rating model which delivers a rating based on a number of variables, some numeric like price, but others might be categorical like color, but since the output does not require category decoding, it is not important.

In an application such as categorization or imputation :cite:`gondara`. Retrieving the category from a vector is crucial. In a training a modern classification model, a categorical output is often subject to an activation function which converts a vector into a probability of each category such as a *softmax* function. Essentially, the softmax is a continuous and differential version of a \`\`hard max'' function which would assign a :code:`1` to the vector representing the most likely category and a :code:`0` to all the other categories. The conversion to a probability distribution allows the use of a negative log likelihood loss function rather than the standard root mean squared error.


Typically, other classic encoding methods use thresholds to determine the approriate representation, which makes them difficult to use as outputs of machine learning systems such as neural networks. The decoding process is difficult to convert to a probability distribution making the more favorable negative log likelihood loss function more difficult to use, furthermore the thresholding operations are generally not differentiable.


Theory
------

In this section, we'll briefly define and discuss quasiorthogonality, show how it relats to one-hot encoding and describe how this relationship can be used to develop a categorical encoding with lower cardinality.

Quasiorthogonality
~~~~~~~~~~~~~~~~~~

In a suitably high dimensional space, two randomly selected vectors are very likely to be nearly orthogonal or quasiorthogonal. In such an :math:`N`-dimensional vector space, there are sets of :math:`K` vectors which are mutually quasiorthogoanl where `K\\gg N.`. A more formal definition can be stated as follows.
Given an :math:`\epsilon` two vectors :math:`{\bf x}` and
:math:`{\bf y}` are said to be *quasiorthogonal* if
:math:`{|{\bf x}\cdot {\bf y}|\over \|{\bf x}\| \|{\bf y}\|}<\epsilon`.
This extends the orthogonality principle by allowing the inner product
to not exactly equal zero. As an extension, we can define a
quasiorthonormal *basis* by a set of normal vectors
:math:`\{{\bf q}_i\}` for :math:`i=1,\ldots,K` such that
:math:`|{\bf q}_i\cdot {\bf q}_j< \epsilon |` and
:math:`||{\bf q}_i||=1`, for all :math:`i,j\in\{1,\ldots,K\}`, where in
principle for large enough :math:`n`, :math:`K\gg n`.

The question of how large a quasiorthonormal basis can be found for a given :math:`n`-dimensional vector space and :math:`\epsilon` is answered in part by the mathematical literature. :cite:`Kainen2020` derived a lower bound for :math:`K` as a function of :math:`\epsilon`
and :math:`n`. Namely,

.. math:: K \ge e^{n\epsilon^2}.

This means that given an :math:`\epsilon` the size of potential quasiorthonormal basis grows at least exponentially as :math:`n` grows.

One Hot Encoding Revisited
~~~~~~~~~~~~~~~~~~~~~~~~~~

The method to exploit quasiorthogonality in categorical encoding
parallels the use of orthonormal basis in one-hot encoding. In machine
learning, the typical aspects of one hot encoding maps a 
variable with :math:`n` categories into a set of unit vectors in a 
:math:`n`-dimensional space: :math:`L=\{l_i\}` for :math:`i=1\ldots n`,
then the one hot encoding :math:`\mathbb{1}_L:L \mapsto \mathbb{R}^n`
given by :math:`l_i \mapsto \mathbf{u}_i` where :math:`\mathbf{u}_i` is
an orthonormal basis in :math:`\mathbb{R}^n`. The simplest basis used is
:math:`\mathbf{u}_i = (0,0,\ldots, 1, 0,\ldots, 0)` where the :math:`1`
is in the :math:`i`\ th position which is know as the *standard basis*
for :math:`\mathbb{R}^n`.

Mapping of a vector back to the original category uses the *argmax*
function, so for a vector :math:`\mathbf{z}`,
:math:`\mathrm{argmax}\mathbf(z) = i` where :math:`z_i>z_j` for all
:math:`j\ne i` and the vector :math:`\mathbf{z}` decodes to
:math:`l_{\mathrm{argmax}(\mathbf{z})}`. Of course, the argmax function
is not easily differentiable which problems in ML learning algorithms
that require derivatives. To fix this, a *softer* version is used called
the *softargmax* or now as simply *softmax* and is defined as follows:

.. math::  \mathrm{softmax}(\mathbf{z})_i={e^{z_i}\over\sum_{j=1}^n e^{z_j}}

for :math:`i=1,2,\ldots,n` and
:math:`{\bf z}=(z_1, z_2,\ldots, z_n) \in \mathbb{R}^n` where
:math:`\mathbf{z}` is the vector being decoded. The softmax function
decodes a one-hote encoded vector into a probability density function
which enables application of negative log likelihood loss functions or
cross entropy losses.

Though one-hot encoding by the nature of its name uses unit vectors
with one :code:`1` in the vector hence a *hot* component. The
formalization of the one hot encoding above allows *any* orthonormal
basis to be used. So to use a generalized one-hot encoding with
orthonormal basis :math:`{\mathbf{u}_i}`, one would map the label
:math:`j` to :math:`{\mathbf{u}_j}` for encoding where the
:math:`{\mathbf{u}_i}` no longer have to take the standard basis form.
To decode an encoded value in this framework, we would take
:math:`i = \mathrm{argmax}(\mathbf{z}\cdot\mathbf{u}_1,\mathbf{z}\cdot\mathbf{u}_2,\ldots,\mathbf{z}\cdot\mathbf{u}_n)`.
This reduces to :math:`\mathrm{argmax}\mathbf(z)` for the standard
basis. Thus, the softmax function can be expressed as the following,

.. math:: \mathrm{softmax}({\bf z})_i={e^{{\bf z}\cdot {\bf u}_i}\over \sum_{j=1}^n e^{{\bf z}\cdot {\bf u}_j}}.

Encoding
~~~~~~~~

The principle behind QOE is simple. A quasiorthonormal basis is
substituted for the orthonormal basis described above. More formally,
we use the quasiorthonormal
basis :math:`\{{\bf q}_i\}` for the orthonormal basis
:math:`\{{\bf u}_i\}` used above. Sogiven a
quasiorthonormal basis, we can define a QOE for a set :math:`L=\{l_i\}`
by :math:`{\mathbb q}(l_i)= {\bf q}_i`. 




encoded values as unit vectors as shown in Table :ref:`qoe`, where :math:`\mathbf{u}_i` are unit vectors in :math:`\mathbb{R}^5` and
:math:`{\mathbf{q}_i}` are a set of quasiorthogonal vectors in a
dimension less than 5. The set :math:`{\mathbf{q}_i}` is
quasiorthonormal if each :math:`\mathbf{q}_i` is normal
(:math:`||\mathbf{q}_i||=1`) and
:math:`|\mathbf{q}_i\cdot \mathbf{q}_j|<\epsilon` for some small
:math:`\epsilon` value and for :math:`i\ne j`. In otherwords, if
:math:`i` and :math:`j` are distinct :math:`\mathbf{q}_i` and
:math:`\mathbf{q}_j` are almost perpendicular.

.. raw:: latex

   \begin{table}
     \begin{longtable*}{lccc}
     \toprule
     \textbf{make} & \textbf{Ordinal} & \textbf{One-Hot} & \textbf{QOE} \\
     \midrule
     \endfirsthead
     Toyota & 1 & $\mathbf{u}_1$ & $\mathbf{q}_1$ \\
     Honda & 2 & $\mathbf{u}_2$ & $\mathbf{q}_2$ \\
     Subaru & 3 & $\mathbf{u}_3$ & $\mathbf{q}_3$ \\
     Nissan & 4 & $\mathbf{u}_4$ & $\mathbf{q}_4$ \\
     Mitsubishi & 5 & $\mathbf{u}_5$ & $\mathbf{q}_5$ \\
     \bottomrule
     \end{longtable*}
     \caption{Example of Quasiorthonormal Encoding \DUrole{label}{qoe}}

   \end{table}


Decoding under QOE would use the
following formula for decoding :math:`\mathbf{z}`:

.. math::

   i =
   \mathrm{argmax}(\mathbf{z}\cdot\mathbf{q}_1,\mathbf{z}\cdot\mathbf{q}_2,\ldots,\mathbf{z}\cdot\mathbf{q}_n)

The analogous softmax function, let's call it *qsoftmax*, would be
expressed as

.. math::

   \mathrm{qsoftmax}({\bf z})_i={e^{{\bf z}\cdot {\bf q}_i}\over \sum_{j=1}^K
   e^{{\bf z}\cdot {\bf q}_j}}

The only real difference in the formulation is that while still
operating in :math:`{\mathbb R}^n` we are encoding :math:`K>n` labels.

Implementation
--------------

Mathematical
~~~~~~~~~~~~

To facilitate modern vectorized computation packages such as ``numpy``
and ``tensorflow``, we define the following :math:`n\times K` *change of
coordinates* matrix

.. math::

   \mathbf{Q}=  \left[\begin{matrix} 
   \bigg| & \bigg| & &\bigg | \\ 
   \mathbf{q}_1 & \mathbf{q}_2 & \cdots & \mathbf{q}_K \\
   \bigg| & \bigg| & &\bigg | \end{matrix}\right].

that transforms between the QOE space and the one hot encoding space. So
given a argmax or softmax function, we can express the quasiorthonormal
variant as follows

.. math:: \mathrm{qargmax}(\mathbf{z}) = \mathrm{argmax}(\mathbf{Qz})

and

.. math:: \mathrm{qsoftmax}(\mathbf{z}) = \mathrm{softmax}(\mathbf{Qz}).

This facilitates optimized functions such as ``softmax`` in libraries
like ``tensorflow`` and using the above matrix enables quick
implementation of QOE into these packages. In the examples below, we use
``tensorflow`` to test the effectiveness of using QOE over one-hot
encoding.

numpy
~~~~~
tensorflow
~~~~~~~~~~
pytorch
~~~~~~~

Construction of an Quasiorthonormal set
---------------------------------------

It is difficult find explicit constructions of quasiorthonormal sets in
the literature. Several methods are mentioned by Kainen :cite:`kainan`, but
these constructions are somewhat theoretical and hard for the lay person
to follow. There are a number of combinatorial problems related such as
spherical codes and Steiner Triple Systems, which strive to find optimal
solutions. As a practical matter, we only need to find fast suboptimal
solutions so we can use spherical
codes :cite:`sphere`. Spherical codes
try to find a set of points on the :math:`n`-dimensional hypersphere
such that the minimum distance between two points is maximized. In most
constructions of spherical codes, a given point's antipodal point is
also in that code set. So in order to get a quasiorthogonal set, for
each pair of antipodal points, only one element of the pair is selected.

Simple Example and Comparison
-----------------------------

As an initial experiment, we applied QOE to classification of the MNIST
handwriting dataset, using the 60000 training examples with 10000 test
examples. As there are 10 categories, we needed sets of quasiorthonormal
bases with 10 elements. We took the spherical code for 24 points in
4-dimensions, giving us 12 quasi-orthogonal vectors. The maximum
pairwise dot product was 0.5 leading to an angle of 60\ :math:`^\circ`.
We also took the spherical code for 56 points in 7-dimensions, giving 28
quasi-orthogonal vectors. The maximum pairwise dot product was .33
leading to an angle of a little over 70\ :math:`^\circ`

We used a hidden layer with 64 units with a ReLU activation function.
Next there is a 20% dropout layer to mitigate overtraining, then an
output layer whose width depends on the encoding used.

As a preliminary, we define a ``qsoftmax`` metafunction:

.. code:: python

    def qsoftmax(basis):
        def func(x):
            qx = tf.matmul(tf.constant(basis),x,transpose_b=True)        
            return tf.nn.softmax(tf.transpose(qx))
        return func

which takes a quasiorthogonal basis and returns the quasiorthogonal
softmax function based on the basis. The various transpose operations
are necessary to conform the inputs and outputs to the shape provided
and required by the tensorflow model.

For ``tensorflow`` and ``keras``, the base network is the following,

.. code:: python

    normal_model = tf.keras.models.Sequential([
      tf.keras.layers.Flatten(input_shape=(28, 28)),
      tf.keras.layers.Dense(64, activation=tf.nn.relu),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(10)
      tf.keras.layers.Activation(tf.nn.softmax)
    ])

We used a separate ``Activation`` layer to make the ``qsoftmax``
clearer.

As a sanity test, you can implement the following:

.. code:: python

    sanity_model = tf.keras.models.Sequential([
      tf.keras.layers.Flatten(input_shape=(28, 28)),
      tf.keras.layers.Dense(64, activation=tf.nn.relu),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(10)
      tf.keras.layers.Lambda(qsoftmax(numpy.identity(10,dtype=numpy.float32)))
    ])

This should function identically as the reference model because it tests
that the qsoftmax function operates as expected (which it does for us)
since applying the identity matrix to ``qsoftmax`` merely converts it to
the standard ``softmax`` function. This is useful for troubleshooting if
you have difficulty.

For the two QOE experiments we labeled the bases for the two
quasiorthonormal sets ``base4`` and ``base7`` and only took the first 10
vectors. We used the following additional test models

.. code:: python

    basis4_model = tf.keras.models.Sequential([
      tf.keras.layers.Flatten(input_shape=(28, 28)),
      tf.keras.layers.Dense(64, activation=tf.nn.relu),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(4),
      tf.keras.layers.Lambda(qsoftmax(basis4))
    ])
    basis7_model = tf.keras.models.Sequential([
      tf.keras.layers.Flatten(input_shape=(28, 28)),
      tf.keras.layers.Dense(64, activation=tf.nn.relu),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(7),
      tf.keras.layers.Lambda(qsoftmax(basis7))
    ])

The following table is the mean of the accuracy over three training runs
of the validation data with training data in parentheses

.. raw:: latex

   \begin{table}
     \begin{longtable*}{lcccc}
     \toprule
     \textbf{Number of} & \textbf{One Hot} & \textbf{7-Dimensional} & \textbf{4-Dimensional} \\
     \textbf{Epochs} & \textbf{Encoding} & \textbf{QOE} & \textbf{QOE} \\
     \midrule
     \endfirsthead
     10 & 97.53\% (97.30\%) & 97.24\% (96.94\%) & 95.65\% (95.15\%) \\
     20 & 97.68\% (98.02\%) & 97.49\% (97.75\%) & 95.94\% (96.15\%) \\
     \bottomrule
     \end{longtable*}
     \caption{Example of Binary Codes}
   \end{table}

+--------------------+--------------------+--------------------+--------------------+
| Number of Epochs   | One Hot Encoding   | 7-Dimensional QO   | 4-Dimensional QO   |
+====================+====================+====================+====================+
| 10                 | 97.53% (97.30%)    | 97.24% (96.94%)    | 95.65% (95.15%)    |
+--------------------+--------------------+--------------------+--------------------+
| 20                 | 97.68% (98.02%)    | 97.49% (97.75%)    | 95.94% (96.15%)    |
+--------------------+--------------------+--------------------+--------------------+

The seven dimensional quasiorthogonal basis (at 70\ :math:`^\circ`),
performs nearly as well as the one-hot encoded version whereas the four
dimensional quasiorthogonal basis (at 60\ :math:`^\circ`) case did not
perform as well. Though 95% vs 98% percent may not seem significant, for
the MNIST handwriting dataset, this relatively small change in
performance is how these classification algorithms are judged.

Spherical Encoding
------------------

One key to the effectiveness of an encoding method is how well
categorical values can be decoded in an noisy environment. Orthogonality
provides excellent decodability especially using the softmax function,
but this comes at the cost of the number of dimensions used for the
encoding. Quasiorthoganility with the QO softmax function performs less
effectively at decoding than orthogonality with the softmax, but reduces
dimensionality.

Separation capabilites of Softmax Function
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A curious observation is that if you examine the effect of the softmax
function on negative values along one of the basis vectors, the softmax
function severely attenuates it. Therefore, one can construct an
orthogonal code using both the 1 and -1 values so for standard unit
vectors, you could encode categorical values to
:math:`\{\mathbf{u}_i, -\mathbf{u}_i,\}`, reducing the dimensionality by
half. Of course nothing comes for free, if a prediction gets confused
between two antipodal unit vectors, the result could be that they cancel
out and allow the noise to dictate the resulting category. By contrast,
for one-hot encoding, the result would get decoded as one of the two
possible values.

With this risk in mind, we can further extend the idea to a
quasiorthogonal basis by adding the antipodal vectors for each vector in
the basis. The result not only doubles the number of vectors that can be
used for encoding, it reduces the problem of finding a basis to that of
finding spherical codes.

Finally, we tested how effective this types of coding is by using an
orthogonal basis in 5 dimensions and adding the antipodal unit vector to
produce a set of 10 vectors.

The model tested becomes:

.. code:: python

    basis5_model = tf.keras.models.Sequential([
      tf.keras.layers.Flatten(input_shape=(28, 28)),
      tf.keras.layers.Dense(64, activation=tf.nn.relu),
      tf.keras.layers.Dropout(0.2),
      tf.keras.layers.Dense(5),
      tf.keras.layers.Lambda(qsoftmax(basis5))
    ])

In addition, we ran a test using the 3 dimension 10 vector spherical
code provided `here <http://neilsloane.com/packings/index.html>`__. The
accuracy is shown in the following table with training accuracy in
parentheses.

.. raw:: latex

   \begin{table}
     \begin{longtable*}{lcccc}
     \toprule
     \textbf{Number of} & \textbf{One Hot} & \textbf{5-Dimensional} & \textbf{3-Dimensional} \\
     \textbf{Epochs} & \textbf{Encoding} & \textbf{Spherical Code} & \textbf{Spherical Code} \\
     \midrule
     \endfirsthead
     10 & 97.53\% (97.30\%) & 96.51\% (96.26\%) & 95.37\% (94.83\%) \\
     20 & 97.68\% (98.02\%) & 96.82\% (97.11\%) & 95.74\% (95.83\%) \\
     \bottomrule
     \end{longtable*}
     \caption{Example of Binary Codes}
   \end{table}

In this case, the 5-dimensional spherical codes performed close to the
one-hot encoding by not as closely as the 7-dimension QO codes. The
3-dimensional spherical codes performed on par with the 4-dimensional QO
codes.

Conclusion
~~~~~~~~~~

While the extreme dimensionality reduction from 10 to 4 or 10 to 3 did
not yield comparable performance to one-hot encoding. More modest
reductions such as 10 to 7 and 10 to 5 did. It is worth considering that
quasiorthogonal or spherical codes are much harder to find in low
dimensions. One should note that, though we went from 10 to 7
dimensions, we did not fully exploit the space spanned by the
quasiorthogonal vector set. Otherwise, we would likely have had the
similar results if the categorical labels had a cardinality of 28 rather
than 10. Furthermore, as the target encoded space approaches 20 or 30
dimensions, we have the ability to encode 100,000 or even a million
labels. So for high cardinality categories, QO encoding and spherical
encoding provide an efficient categorical encoding while controlling the
curse of dimensionality.

References
----------
